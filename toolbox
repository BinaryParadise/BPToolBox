#!/usr/bin/ruby -w
require 'fileutils'
require 'json'
require 'yaml'
require 'xcodeproj'

Arg_Name_ConfigPath   = "--config"
Arg_Name_ProjectPath  = "--project"
Arg_Name_SourcePaths  = "--sourcePaths"
Arg_Name_Prefix       = "--prefix"
OC_Extension          = [".h", ".mm", ".m", ".xib", ".storyboard", ".pch", ".swift"]
Image_Extension       = [".png", ".jpg", ".jpeg"]
Ignore_Files          = ["main.m", "main.mm"]

# author: çµé•œ
# ç”¨æ¥ä¿®æ”¹ç±»åå‰ç¼€
# 2019-09-19
class Confuse
  attr_accessor:directory   # å·¥ä½œç›®å½•
  attr_accessor:projectPath # é¡¹ç›®æ–‡ä»¶ç›®å½•
  attr_accessor:sourcePaths # æºç ç›®å½•åˆ—è¡¨
  attr_accessor:imagePaths  # å›¾ç‰‡ç›®å½•åˆ—è¡¨
  attr_accessor:old_prefix  # ä¹‹å‰å‰ç¼€
  attr_accessor:new_prefix  # æ–°å‰ç¼€
  attr_accessor:ignorePaths # å¿½ç•¥ç›®å½•åˆ—è¡¨
  attr_accessor:prefixMap   # æ›¿æ¢çš„æ˜ å°„è¡¨
  attr_accessor:sourceFiles # æºç æ–‡ä»¶åˆ—è¡¨
  attr_accessor:ignoreCategory # å¿½ç•¥ç±»åˆ«
  attr_accessor:podfile     # podfile
  def initialize(args)
    puts "version: "+RUBY_VERSION
    processArgs(args)
  end

  def processArgs(args)
    @ignorePaths = []
    @sourceFiles = []
    @prefixMap = Hash.new

    actionType = args[0]
    if actionType.nil?
      Confuse::showUsage()
      return
    end
    configPath = args[1].eql?(Arg_Name_ConfigPath) ? args[2] : '.toolbox.yml'
    if configPath && File.exist?(configPath)
      properties = YAML.load_file(Pathname(configPath).to_path)
      @directory = properties['directory']
      Dir.chdir(@directory)
      @projectPath = properties['project']
      @sourcePaths = properties['sourcePaths']
      @ignorePaths = properties['ignorePaths']||[]
      @imagePaths  = properties["imagePaths"]
      @includeCategory = properties['includeCategory']
      @podfile = properties['podfile']
      @old_prefix = properties['prefix'].split("=").first
      @new_prefix = properties['prefix'].split("=").last
      if actionType.eql?('prefix')
        puts Confuse::debug("é…ç½®æ–‡ä»¶#{configPath}å·²åŠ è½½...")
        if @ignorePaths.length > 0
          puts Confuse::info("å¿½ç•¥çš„ç›®å½•  #{@ignorePaths}")
        end
        prefixAction()
      elsif actionType.eql?('image')
        imageAction()
      end
    else
      puts Confuse::error("ç¼ºå°‘å‚æ•°#{Arg_Name_ConfigPath}ä¸”è€…æ‰¾ä¸åˆ°é»˜è®¤æ–‡ä»¶.toolbox.yml #{Dir.pwd}",true)
      Confuse::showUsage()
      return nil
    end

  end

  def prefixAction()
    @sourcePaths.each{|item|
      (
        if File::exist?(item)
          replaceFileClassName(Pathname("#{item}").to_path)
        else
          puts Confue::error("æ–‡ä»¶å¤¹ä¸å­˜åœ¨ #{item}")
        end
      )}
    puts ""
    puts Confuse::debug("å…±è®¡ #{@sourceFiles.count} é¡¹å®Œæˆé‡å‘½å...")
    replaceProject()
    replacePodfile()
  end

  def imageAction()
    images = []
    puts "æ­£åœ¨æ”¶é›†ä¿¡æ¯..."
    sleep 1
    magick = `which magick`
    if magick.include?('not found')
      puts Confue::error('æ‰¾ä¸åˆ°å‘½ä»¤ imagemagick å‡†å¤‡å¼€å§‹å®‰è£…...')
      `brew install imagemagick`
      return
    end
    @imagePaths.each{|item|
    (
      updateImage(item,images)
    )}
    count = 0;

    puts Confuse::info("ğŸºæ”¶é›†å®Œæˆï¼Œå‡†å¤‡å¤„ç†...")
    images.each{|item|
    (
      count = count + 1
      `magick #{item} #{item}`
      print ("æ­£åœ¨å¤„ç†...#{count}/#{images.length} #{item}").ljust(220) + " \r"
      STDOUT.flush
    )}
    puts ""
    puts Confuse::debug("å¤„ç†å®Œæˆï¼Œå…±è®¡ #{count} ä¸ªå›¾ç‰‡æ›´æ–°...")
  end

  def updateImage(sourcePath, images)
    if !File::exist?(sourcePath)
      return
    end

    Dir::entries(sourcePath).each{|item|
    (
      subPath = sourcePath+"/"+item
      if File.directory?(subPath)
        if !(item.eql?('.') || item.eql?('..'))
          updateImage(subPath, images)
        end
      else
        if Image_Extension.include?(File.extname(item))
          images.push(subPath)
        end
      end
    )}
  end

  # æ›¿æ¢ç±»åå‰ç¼€
  def replaceFileClassName(sourcePath)
    Dir::entries(sourcePath).each{|item|(
      subPath = sourcePath+"/"+item
      if File.directory?(subPath) || File.extname(subPath).eql?(".lproj")
        if !(item.eql?('.') || item.eql?('..'))
          replaceFileClassName(subPath)
        end
      else
          replaceClassPrefix(subPath)
      end
      )}
  end

  def replaceClassPrefix(file)
    if File::exist?(file) && OC_Extension.include?(File.extname(file))
      if (@includeCategory.nil? || !@includeCategory) && !File.basename(file).match(/\+\b(\w+)\b/).nil?
        # puts Confuse::debug("å¿½ç•¥ç±»åˆ« #{file}")
        addMapping(file, file)
        return
      end
      if @ignorePaths.select { |e| file.gsub(/#{Dir.pwd}/, "").start_with?(e) }.length > 0 || File.extname(file).eql?(".pch")
        # å¿½ç•¥çš„æ–‡ä»¶éœ€è¦æ›¿æ¢å†…å®¹
        # pchä¸é‡å‘½å
        addMapping(file, file)
        return
      end
      fileName = File.basename(file)
      if Ignore_Files.include?(fileName)
        addMapping(file, file)
      elsif fileName.start_with?(@old_prefix)
        newName = File.dirname(file) + '/' + @new_prefix + fileName[@old_prefix.length, fileName.length-@old_prefix.length]
        # File.rename(file, newName)
        `git mv -k #{file} #{newName}`
        addMapping(file, newName)
      elsif !fileName.start_with?(@new_prefix)
        newName = File.dirname(file) + '/' + @new_prefix + fileName
        # File.rename(file, newName)
        `git mv -k #{file} #{newName}`
        addMapping(file, newName)
      else
        addMapping(file, file)
      end
    end
  end

  def replaceProject()
    puts "å¼€å§‹æ›´æ–°æ–‡ä»¶å†…å®¹å¼•ç”¨..."
    fileIndex = 0
    @sourceFiles.each{|filePath|
      (
        nFile = File.read(filePath)
        nBuffer = nFile
        # TODO:åŒ¹é…æ–‡ä»¶ä¸­æ‰€æœ‰çš„ç±»åçœ‹æ˜¯å¦éœ€è¦æ›¿æ¢ï¼ˆæå‡æ•ˆç‡ï¼‰
        @prefixMap.each{|key,value|
          (
            # æ›¿æ¢importï¼Œä¸æ”¯æŒ<xxxxx.h>
            nBuffer = nBuffer.gsub(/([\/\"])(\b#{key}\b)([^\/\+])/) do |match1|
              match1.gsub($~[2], "#{value}")
            end

            # æ›¿æ¢å†…å®¹
            nBuffer = nBuffer.gsub(/([^\/\+#"])(\b#{key}\b)([^\/+])/) do |match2|
              match2.gsub($~[2], "#{value}")
            end
          )}

        if File.extname(filePath).eql?(".xib")
          nBuffer = nBuffer + "\n"
        end
        if !nFile.eql?(nBuffer)
          File.open(filePath, "r+") do |aFile|
            aFile.syswrite(nBuffer)
         end
         print Confuse::warn("æ›´æ–° #{fileIndex}\/#{sourceFiles.count} #{filePath.gsub(/#{Dir.pwd}\//,"")}").ljust(200)+" \r"
         STDOUT.flush
        end
        fileIndex = fileIndex+1

      )}

    puts Confuse::warn("å…±è®¡ #{@sourceFiles.length} å®Œæˆæ›´æ–°...")
    buffer = File.read("#{@projectPath}/project.pbxproj")
    @prefixMap.each{|key,value|
      (
        buffer = buffer.gsub(/([^+])(\b#{key}\b)([.])/) do |match|
          match.gsub($~[2], "#{value}")
        end
      )}

   File.open("#{@projectPath}/project.pbxproj", "w") do |aFile|
      aFile.syswrite(buffer)
      puts "æ›´æ–° " + Confuse::warn("#{@projectPath}/project.pbxproj")
   end

   puts Confuse::error("PS: è¯·å…ˆæäº¤é‡å‘½åçš„æ–‡ä»¶ï¼Œå†æäº¤å†…å®¹å˜æ›´çš„æ–‡ä»¶!!!ğŸº")

  end

  def replacePodfile()
    if @podfile.nil?
      return
    end
    puts "æ›´æ–°\t" + Confuse::warn(@podfile)
    buffer = File.read("#{@podfile}")
    @prefixMap.each{|key,value|(
      if buffer.nil?
        puts "#{key} #{value}"
      end
        buffer = buffer.gsub(/"\b#{key}\b/, value)
      )}
    File.write("#{@podfile}", buffer)
  end

  # æ·»åŠ æ˜ å°„å…³ç³»
  def addMapping(oldPath, newPath)
    if !@sourceFiles.include?(newPath)
      @sourceFiles.push(newPath)
    end
    oldName = File.basename(oldPath, File.extname(oldPath))
    newName = File.basename(newPath, File.extname(newPath))
    if !@prefixMap.has_key?(oldName)
      @prefixMap[oldName] = newName
      # internalClass(newPath)
      if !oldPath.eql?(newPath)
        path = oldPath.gsub(/#{Dir.pwd}\//,"")
        print Confuse::debug("é‡å‘½å #{path}").ljust(200) + " \r"
        STDOUT.flush
      end
    end

  end

  # å†…éƒ¨ç±»(å’Œæ–‡ä»¶åä¸åŒ)
  def internalClass(filePath)

    buffer = File.read('newPath')
    # é€†åºç¯è§†
    buffer.match(/(?<=@interface)\s+\b\w+\b/).to_a.each
  end

  def self.showUsage()
    puts "ç”¨æ³•: command #{Confuse::warn('[é€‰é¡¹]')}

å‘½ä»¤:
    image         ä¿®æ”¹å›¾ç‰‡hash
    prefix        ä¿®æ”¹ç±»ç›®å‰ç¼€,æš‚ä¸æ”¯æŒå†…éƒ¨ç±»

é€‰é¡¹:
    --config      é…ç½®æ–‡ä»¶ç›®å½•ï¼ˆæ¨è, å…¶å®ƒå‚æ•°å°†å¤±æ•ˆï¼‰
    "
  end

  # æé†’
  def self.warn(msg)
    return "\033[32m#{msg}\033[0m"
  end

  # ä¿¡æ¯
  def self.info(msg)
    return "\033[37m#{msg}\033[0m"
  end

  # è°ƒè¯•
  def self.debug(msg)
    return "\033[35m#{msg}\033[0m"
  end

  # é”™è¯¯
  def self.error(msg, newline = false)
    return newline ? "\033[31m#{msg}\033[0m\n":"\033[31m#{msg}\033[0m"
  end

end

Confuse::new(ARGV)
